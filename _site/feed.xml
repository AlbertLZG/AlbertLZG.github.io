<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Albert_LZG's Blog</title>
    <description>李志刚|读书·编程·思</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 15 Feb 2017 22:12:43 +0800</pubDate>
    <lastBuildDate>Wed, 15 Feb 2017 22:12:43 +0800</lastBuildDate>
    <generator>Jekyll v3.4.0</generator>
    
      <item>
        <title>lintcode “丑数 II” 题解</title>
        <description>&lt;p&gt;题目如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ugly Number II&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ugly number is a number that only have factors 2, 3 and 5.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Design an algorithm to find the nth ugly number. The first 10 ugly numbers are 1, 2, 3, 4, 5, 6, 8, 9, 10, 12…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Notice&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note that 1 is typically treated as an ugly number.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Have you met this question in a real interview? Yes
Example
If n=9, return 10.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Challenge 
O(n log n) or O(n) time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;丑数 II&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;设计一个算法，找出只含素因子2，3，5 的第 n 大的数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;符合条件的数如：1, 2, 3, 4, 5, 6, 8, 9, 10, 12…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意事项&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们可以认为1也是一个丑数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;您在真实的面试中是否遇到过这个题？ Yes
样例
如果n = 9， 返回 10&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;题解：&lt;/p&gt;

&lt;p&gt;由题目要求计算复杂度为O(nlogn)或者O(n)可知，直接暴力枚举时不行的
比如下面：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//c++:
class Solution {  
public:  
    /* 
     * @param n an integer 
     * @return the nth prime number as description. 
     */  
    int nthUglyNumber(int n) {  
        // write your code here  
        int countN = 0;  
        int m = 0;  
        int lastNumber = 2;  
        while(countN &amp;lt; n)  
        {  
            m++;  
            int number = m;  
            while(number % 2 == 0)  
                number = number / 2;  
            while(number % 3 == 0)  
                number = number / 3;  
            while(number % 5 == 0)  
                number = number / 5;  
            if(number == 1)  
            {  
                countN++;  
            }  
        }  
        return m;  
    }  
};  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;由丑数的定义可知，任何一个丑数都是2^i&lt;em&gt;3^j&lt;/em&gt;5^k这种形式的，并且任意一个丑数乘以2、3、5后均可以得到新的丑数。&lt;/p&gt;

&lt;p&gt;1）第一个丑数ugly[0]为1，此时i = j = k = 0。&lt;/p&gt;

&lt;p&gt;2）求解第二个丑数：&lt;/p&gt;

&lt;p&gt;ugly[1] = min(ugly[0]&lt;em&gt;2, ugly[0]&lt;/em&gt;3, ugly[0]&lt;em&gt;5) = min(1&lt;/em&gt;2, 1&lt;em&gt;3, 1&lt;/em&gt;5) = 2 = 2^1&lt;em&gt;3^0&lt;/em&gt;5^0
即此时的i = 1。&lt;/p&gt;

&lt;p&gt;3）求解第三个丑数：&lt;/p&gt;

&lt;p&gt;ugly[2] = min(ugly[1]&lt;em&gt;2, ugly[0]&lt;/em&gt;3, ugly[0]&lt;em&gt;5) = min(2&lt;/em&gt;2, 1&lt;em&gt;3, 1&lt;/em&gt;5) = 3 = 2^0&lt;em&gt;3^1&lt;/em&gt;5^0
即此时的j = 1&lt;/p&gt;

&lt;p&gt;思考:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、为什么这里要用2前面的乘数是ugly[1]而不是ugly[0]?
	
因为ugly[0]*2已经作为第二个丑数赋值给了ugly[1]。

2、为什么这三个数的最小值就是还没有添加到丑数序列中的所有丑数的最小值？

因为任意一个丑数乘以2、3、5后均可以得到新的丑数，同时，任意一个丑数都可以由前面的某一丑数乘以2、3或者5得到，除了第一个丑数1。因此还没有添加进丑数序列的丑数有：

ugly[0]*2*2, ugly[0]*2*2*2, ……（ugly[0]*2已经作为第二个丑数赋值给了ugly[1]）

ugly[1]*2, ugly[1]*2*2,……（注意ugly[1]*2 = ugly[0]*2*2，…… ）

ugly[2]*2, ugly[2]*2*2,……

……

ugly[n]*2, ugly[n]*2*2,……

这里面最小的数是ugly[1]*2。

同理，

ugly[0]*3, ugly[0]*3*3,……

ugly[1]*3,……

……

里面最小的数是ugly[0]*3


ugly[0]*5, ugly[0]*5*5,……

ugly[1]*5,……

……

里面最小的数是ugly[0]*5

因此只需要比较ugly[1]*2, ugly[0]*3, ugly[0]*5三个数，将其中的最小值作为下一个要添加的丑数即可。

3、为什么这里要用3和5前面的乘数是ugly[0]而不是ugly[1]?

因为ugly[1]&amp;gt;ugly[0],而ugly[0]*3和ugly[0]*5均是还没有添加进丑数序列的丑数，它们都分别比ugly[1]*3和ugly[1]*5小。

4、那2、3、5前面的乘数应该等于多少？

由上面两个问题可知，由于ugly[0]*2已经作为第二个丑数赋值给了ugly[1]，所以这里的2前面的乘数应该是ugly[0]*2*2 = ugly[1]*2。即初始时设置索引变量index2=index3=index5=0分别代表相应乘数前面的数字是哪个丑数，即ugly[index2],ugly[index3],ugly[index5]。每当ugly[index2]*2被添加进丑数序列中时，令index2增加一，否则保持不变。3和5同理。下面用该方法求第四个丑数：)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4）求解第四个丑数：&lt;/p&gt;

&lt;p&gt;ugly[2] = min(ugly[1]&lt;em&gt;2, ugly[1]&lt;/em&gt;3, ugly[0]&lt;em&gt;5) = min(2&lt;/em&gt;2, 1&lt;em&gt;3, 1&lt;/em&gt;5) = 3 = 2^0&lt;em&gt;3^1&lt;/em&gt;5^0&lt;/p&gt;

&lt;p&gt;初识时令index2=index3=index5=0；&lt;/p&gt;

&lt;p&gt;求第二个丑数时得到ugly[index2]&lt;em&gt;2=ugly[0]&lt;/em&gt;2=2是该值，因此index2从0增加到1；&lt;/p&gt;

&lt;p&gt;求第三个丑数时得ugly[index3]&lt;em&gt;3=ugly[0]&lt;/em&gt;3=3是该值，因此index3从0增加到1；&lt;/p&gt;

&lt;p&gt;求第四个丑数时index2=1，index3=1，index5=0，因此比较ugly[1]&lt;em&gt;2, ugly[1]&lt;/em&gt;3, ugly[0]&lt;em&gt;5三个数，得ugly[1]&lt;/em&gt;2是其中最小值，是第四个丑数，这时另index2从1增加到2。&lt;/p&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;p&gt;注意：代码需要考虑有重数问题，即当ugly[index2]&lt;em&gt;2, ugly[index3]&lt;/em&gt;3, ugly[index5]&lt;em&gt;5三个数字有2个或者全部数字相等时应怎样？比如ugly[index2]&lt;/em&gt;2 = ugly[index3]&lt;em&gt;3时，正确的做法应该是index2和index3都增加1，因为将ugly[index2]&lt;/em&gt;2添加进丑数序列就意义着ugly[index3]*3也被添加进去了。下面两段代码均有考虑该情况。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#python：
class Solution:
    
    &quot;&quot;&quot;
    
    @param {int} n an integer.
    
    @return {int} the nth prime number as description.
    
    &quot;&quot;&quot;
    
    def nthUglyNumber(self, n):
    
        # write your code here
    
        ugly = [1]
    
        index2 = 0
    
        index3 = 0
    
        index5 = 0
    
        for i in range(n):
    
            temp_ugly = min(ugly[index2]*2,ugly[index3]*3,ugly[index5]*5)
    
            ugly.append(temp_ugly)
    
            index2 +=1 if temp_ugly &amp;gt;= ugly[index2]*2 else 0
    
            index3 +=1 if temp_ugly &amp;gt;= ugly[index3]*3 else 0
    
            index5 +=1 if temp_ugly &amp;gt;= ugly[index5]*5 else 0
    
        return ugly[n-1]


//c++：
class Solution {  
public:  
    /* 
     * @param n an integer 
     * @return the nth prime number as description. 
     */  
    int nthUglyNumber(int n) {  
        // write your code here  
        int *ugly = new int[n];  
        ugly[0] = 1;  
        int num_2 = 0;  
        int num_3 = 0;  
        int num_5 = 0;  
        for(int i = 1;i&amp;lt;n;i++)  
        {  
            ugly[i] = min(min(ugly[num_2]*2,ugly[num_3]*3),ugly[num_5]*5);  
            if(ugly[i] / ugly[num_2] == 2)  
                num_2 ++;  
            if(ugly[i] / ugly[num_3] == 3)  
                num_3 ++;  
            if(ugly[i] / ugly[num_5] == 5)  
                num_5 ++;  
        }  
        return ugly[n-1];  
    }  
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AlbertLZG/AlbertLZG.github.io/master/img/blog_logo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 15 Feb 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2017/02/15/lintcode-%E4%B8%91%E6%95%B0II-%E9%A2%98%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2017/02/15/lintcode-%E4%B8%91%E6%95%B0II-%E9%A2%98%E8%A7%A3/</guid>
        
        <category>算法</category>
        
        <category>数据结构</category>
        
        <category>lintcode</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>关于这个博客</title>
        <description>&lt;p&gt;##关于为什么想要开自己的博客？&lt;/p&gt;

&lt;p&gt;博客已经火了好多年了，早已不是什么新鲜事物，并且有那么多的博客网站，注册个账号即可，为什么还要费这么大劲儿整个自己的博客网站？我今天也纠结了一下，但觉得还是得整个自己的博客网站，原因如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其一：如想拥有属于自己的博客的想法由来以久，虽然很多年前我就在CSND、博客园等技术博客网站上面都申请账号，收藏、转载自己喜欢的文章（CSDN禁止转载），但仅仅把博客作为自己收藏优秀的文章的一个资料库，当时的初衷就是希望有个将自己在网上看过的优秀的技术文章收集起来的办法，而这些技术博客网站无疑是十分便捷的。只需要注册个账号即可实现目的。但是，后来发现这给我带来的提升是十分有限的，一些时候为了解决某些问题而找到的好的解决方案在被收藏进自己的账号之后便再也未曾阅览过。而技术博客网站的界面风格又使得我提不起在里面写文章的欲望。正所谓买书不如借书，优秀的文章一经收藏便如石沉大海般沉寂。独乐乐不如众乐乐，一些知识自己学会并不见得真的理解透了，能够给别人讲明白才算是真的掌握了。而建个自己的博客无意可以起到这两方面的作用。一方面，自己学会的知识，要能够以大多数人都理解的方式写出来，既是给别人看，也是给很长时间之后的自己看；另一方面，对于优秀的技术文章，必须经过自己的一番编辑整理才可以加进自己的博客（当然一定要注明文章来源～），相比之前的轻轻一点就收藏了，自然印象要深刻得多了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;其二：当今时代，世界越来越平坦（感兴趣的可以读下《世界是平的》），互联网时代，知识随手可得、随处可见。技术的开源时代新技术的开发与普及速度大大加快，而论文的开放获取、遍地都是的公开课使得前沿知识、高等教育被任何人在任何时候都可以接受。很多公司正是源于某一开源项目，而无数创意和想法也在开源项目中诞生。在这样的大潮中，积极地参与其中，才是提高自己的最有效的方式。积极地获取最新知识、参与开源项目的开发中，并积极地传播知识，才能最快的提升自己。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;其三：博客是开放给所有人看的，由于内容是写给大家看的，自然就会感到警醒，写得不好会被读者骂的，而这也正好可以起到督促自己认真总结知识的目的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由以上三点，我决定还是费了大半天时间，搭建个属于自己的网站。&lt;/p&gt;

&lt;p&gt;##立Flag&lt;/p&gt;

&lt;p&gt;为督促自己每日的学习，在此立下Flag：&lt;/p&gt;

&lt;p&gt;###一、按时将学到的数据结构与算法方法的知识更新到博客&lt;/p&gt;

&lt;p&gt;###二、按时将OJ网站上刷的题更新到博客&lt;/p&gt;

&lt;p&gt;###三、按时将读到的最新paper及自己的看法更新到博客&lt;/p&gt;

&lt;p&gt;以上三点中的按时的含义是：有则更新，每日小更新，定期大更新。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AlbertLZG/AlbertLZG.github.io/master/img/blog_logo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 15 Feb 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2017/02/15/About-this-blog/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2017/02/15/About-this-blog/</guid>
        
        <category>说明</category>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
